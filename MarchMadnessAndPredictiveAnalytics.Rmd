---
title: "March Madness 2017 and Predictive Analytics"
author: "Jared Endicott"
date: "Tuesday, March 14, 2017"
output: 
  html_document:
    keep_md: yes
    fig_width: 9
    fig_height: 6
---

<div style="width:450px; height=300px">
<img src="https://raw.githubusercontent.com/RealizingFutures/MarchMadness2017/gh-pages/MarchMadnessAndPredictiveAnalytics_files/figure-html/iStock-MarchMadness.jpg">
</div>
<br>



### From March Apathy to March Madness


When it comes to college basketball I'm about as ignorant as they come. I have a vague awareness of March Madness and the Final Four, mostly through tangential knowledge like President Obama filling out a tournament bracket each year and Warren Buffet offering a billion dollar prize for a perfect bracket prediction in 2014. I have never filled out a bracket before. I have never even watched an NCAA game before. I couldn't tell you about the teams or the players. That all changes this year. 

I have been challenged by the idea of using predictive analytics to fill out the 2017 March Madness brackets. To train for this effort I have watched about a dozen lectures on the topic...well...I have watched the same lecture about a dozen times. The talk in question is from a **Great Courses** lecture series called *Big Data: How Data Analytics Is Transforming the World* and it is appropriately titled "<a href="https://www.thegreatcoursesplus.com/big-data-how-data-analytics-is-transforming-the-world/bracketologythe-math-of-march-madness/" target="_blank">Bracketology-The Math of March Madness</a>." In the lecture, Professor Tim Chartier explains some basics about the tournament and then proceeds to lay out a particular data-centered approach to forecasting which teams will win which playoff games. 

Professor Chartier demonstrates the <a href="http://public.gettysburg.edu/~cwessell/RankingPage/massey.pdf" target="_blank">Massey Method</a>, an algorithm created by mathematics professor Kenneth Massey for ranking NCAA college football teams for the Bowl Championship Series. The method can be applied to college basketball as well, and uses game data from the regular season to rank all of the teams. Whoever has the highest rank in any given matchup is favored to win that matchup and the algorithm assumes the winner of any matchup to be the higher ranking team. The algorithm takes into account the point spreads in each of the regular season games, such that the winning team has a positive score differential and the losing team has a negative score differential, thus weighting the winners and losers by their net score differentials for the entire season. Point spreads can be capped, so that blowouts and teams who have easier schedules don't overweight the rankings. The method also accommodates various approaches for weighting the games themselves, such as weighting away and neutral territory games higher than home games and/or weighting more recent games higher than games earlier in the season. All in all, this algorithm looks like it could be a scoring leader.

The data for this analysis was made available by **Kaggle** in the form of CSVs. Kaggle is a website that hosts data science competitions, including an annual <a href="https://www.kaggle.com/c/march-machine-learning-mania-2017/" target="_blank">March Machine Learning Mania</a> for the NCAA March Madness Tournament. As cited by Kaggle the data is ultimately provided by Kenneth Massey himself. 


### Calculate NCAA Rankings

I used R, a preferred language for data scientists, to write a function that will calculate NCAA Division I Men's Basketball team rankings using the Massey Method as explained by Professor Chartier. This algorithm follows this general recipe for calculating the rankings using a linear system:

1) Calculate each team's net point differential from the regular season games and save these in a vector (V).
2) Calculate a winning team by losing team matrix (M) that has the amount of games each team has played as well as a multiple of -1 for each matchup between two given teams.
3) Solve the equation M * Rankings = V, where the teams in V are aligned with the teams in the rows of M.
4) Calculate the inverse of M.
5) Multiply the inverse of M by V to obtain the Rankings.

For a more in depth understanding of the mathematical ideas behind this algorithm I suggest acquiring Professor Chartier's lectures on <a href="https://www.thegreatcoursesplus.com/big-data-how-data-analytics-is-transforming-the-world" target="_blank">*Big Data*</a> from The Great Courses.

The R function below may not be too pretty, but it gets the jobs done and returns a list of rankings. There are various parameters that can be passed to the function. These parameters include the year of the tournament, a cap for each game's point spread, a weight for away games, and weights for games played in different quarters of the season. There is also a parameter that will allow me to set a number of randomly chosen upsets in round 1, such that a lower ranked team will beat the higher ranked team in that game. These parameters allow for new rankings to be calculated very quickly under different scenarios.

```{r, message=FALSE, warning=FALSE}

# load libraries
library(dplyr)
library(reshape2)
library(MASS)
library(TeachingDemos)
library(png)
library(ggplot2)
library(RColorBrewer)


```


```{r, message=FALSE, warning=FALSE}



GetNCAARankings <- function(myYear, myScoreCap, myLocMod
                            , myQ1Mod, myQ2Mod, myQ3Mod, myQ4Mod){
# this function calculates and returns NCAA rankings 
# for a given regular season and set of parameters        
        
        #set file paths
        fp.RegularSeasonCompactResults <- 
                'C:/Users/Jared/Documents/R/MarchMadness/RegularSeasonCompactResults.csv'
        fp.Teams <- 
                'C:/Users/Jared/Documents/R/MarchMadness/Teams.csv'
        
        # load files into data frames
        data.RegularSeasonCompactResults <- read.csv(fp.RegularSeasonCompactResults)
        data.Teams <- read.csv(fp.Teams)
        
        
        # filter, mutate, and arrange dataset
        data.quarter <- data.RegularSeasonCompactResults %>%
                filter(Season == myYear)
        
        q1 <- (max(data.quarter$Daynum) - min(data.quarter$Daynum)) / 4
        q2 <- (max(data.quarter$Daynum) - min(data.quarter$Daynum)) / 2
        q3 <- ((max(data.quarter$Daynum) - min(data.quarter$Daynum)) / 2) + 
                ((max(data.quarter$Daynum) - min(data.quarter$Daynum)) / 4)
        
        
        # filter, mutate, and arrange dataset
        data.wins <- data.RegularSeasonCompactResults %>%
                filter(Season == myYear) %>%
                mutate(counter = 1) %>%
                mutate(ScoreDiff = Wscore - Lscore) %>%
                mutate(ScoreDiff = ifelse(ScoreDiff >= myScoreCap, myScoreCap, ScoreDiff)) %>%
                mutate(ScoreDiff = ifelse(Wloc == 'A|N', ScoreDiff * myLocMod, ScoreDiff))
        
        data.wins <- data.wins %>%
                mutate(ScoreDiff = 
                        ifelse(Daynum <= q1
                               , ScoreDiff * myQ1Mod
                               , ifelse(Daynum <= q2
                                        , ScoreDiff * myQ2Mod
                                        , ifelse(Daynum <= q3
                                                , ScoreDiff * myQ3Mod
                                                , ScoreDiff * myQ4Mod)))) %>%
                group_by(Wteam) %>%
                summarise(ScoreDiff = sum(ScoreDiff), Games = sum(counter)) %>%
                arrange(desc(ScoreDiff))
     
        # filter, mutate, and arrange dataset
        data.losses <- data.RegularSeasonCompactResults %>%
                filter(Season == myYear) %>%
                mutate(counter = 1) %>%
                mutate(ScoreDiff = Lscore - Wscore) %>%
                mutate(ScoreDiff = ifelse(ScoreDiff <= myScoreCap * -1, myScoreCap * -1, ScoreDiff)) %>%
                mutate(ScoreDiff = ifelse(Wloc == 'A|N', ScoreDiff * myLocMod, ScoreDiff))
                
        data.losses <- data.losses %>%
                mutate(ScoreDiff = 
                        ifelse(Daynum <= q1
                               , ScoreDiff * myQ1Mod
                               , ifelse(Daynum <= q2
                                        , ScoreDiff * myQ2Mod
                                        , ifelse(Daynum <= q3
                                                , ScoreDiff * myQ3Mod
                                                , ScoreDiff * myQ4Mod)))) %>%
                group_by(Lteam) %>%
                summarise(ScoreDiff = sum(ScoreDiff), Games = sum(counter)) %>%
                arrange(desc(ScoreDiff))        
                                
        # change the Wteam and Lteam field names to be Team_Id
        names(data.wins)[1] <- 'Team_Id' 
        names(data.losses)[1] <- 'Team_Id'
        
        # bind the wins and losses and then summarise final scores differences
        data.sum <- rbind(data.wins, data.losses)
        data.sum <- data.sum %>%
                group_by(Team_Id) %>%
                summarise(ScoreDiff = sum(ScoreDiff))
        
        # create a data frame with teams and all zeroes to use as a 
        # base to build the score difference vector
        data.sum.base <- data.frame(Team_Id = as.character(data.Teams$Team_Id)
                                    , ScoreDiff = as.numeric(0))
        rownames(data.sum.base) <- data.sum.base$Team_Id
        
        # load the data frame with the cumulative score differences for each team
        for(i in 1:nrow(data.sum)){
                Tid <- as.character(data.sum[i, 1])
                TScoreDiff <- data.sum[i, 2]
                data.sum.base[Tid, 2] <- TScoreDiff
        }
        
        # create a data frame with all zeroes 
        # to use for building a matrix of matchups
        data.mat.base <- data.frame(Wteam = as.character(data.Teams$Team_Id)
                                    , Lteam = as.character(data.Teams$Team_Id)
                                    , Games = as.numeric(0))
        data.mat.base <- dcast(data.mat.base, Wteam ~ Lteam, fill = 0)
        rownames(data.mat.base) <- data.mat.base$Wteam
        drops <- c('Wteam')
        data.mat.base <- data.mat.base[ , !(names(data.mat.base) %in% drops)]
        
        # create a data frame with the count of games played by team
        data.games <- rbind(data.wins, data.losses)
        data.games <- data.games %>%
                group_by(Team_Id) %>%
                summarise(Games = sum(Games)) 
        
        # load the matrix with the number of games played by each team 
        # corresponding to cells where teams intersect themselves
        for(i in 1:nrow(data.games)){
                Tid <- as.character(data.games[i, 1])
                Tgames <- data.games[i, 2]
                data.mat.base[rownames(data.mat.base) == Tid
                              , colnames(data.mat.base) == Tid] <- Tgames
        }
        
        # filter, mutate, and arrange dataset
        data.matchups <- data.RegularSeasonCompactResults %>%
                filter(Season == myYear) %>%
                mutate(counter = -1) %>%
                group_by(Wteam, Lteam) %>%
                summarise(Matchups = sum(counter))
        
        # load the matrix based on the number of matchups between each team
        for(i in 1:nrow(data.matchups)){
                Wtid <- as.character(data.matchups[i, 1])
                Ltid <- as.character(data.matchups[i, 2])
                Tmatch <- data.matchups[i, 3]
                data.mat.base[rownames(data.mat.base) == Wtid
                             , colnames(data.mat.base) == Ltid] <- Tmatch        
                data.mat.base[rownames(data.mat.base) == Ltid
                             , colnames(data.mat.base) == Wtid] <- Tmatch                   
        }
        
        # change data frame into a matrix
        data.mat <- as.matrix(data.mat.base)
        
        # create rankings by calculating the inverse of the matrix
        # then multiplying the inverted matrix by the vector of 
        # cumulative score differences
        rankings <- round(ginv(data.mat) %*% data.sum.base[, 2], 3)
        
        # create a dataset with rankings and sort it
        data.rank <- cbind(data.Teams, rankings)
        data.rank <- arrange(data.rank, desc(rankings))
        
        return(data.rank)
             
}

```


### Simulate March Madness

This next chunk of code simulates the March Madness tournament, starting with 64 teams and simulating matchups in each subsequent round until there is one champion. The outcomes of the games are determined by the rankings that we calculated previously, such that for each matchup the team with the higher ranking is presumed to win.  


```{r, message=FALSE, warning=FALSE}

SimulateMarchMadness <- function(myData, myYear, myUpsets, coinFlip = FALSE){
# this function takes some NCAA rankings data and 
# uses it to predict March Madness brackets         
        
        # set file paths and get the data
        fp.seeds <- 
                'C:/Users/Jared/Documents/R/MarchMadness/TourneySeeds.csv'
        fp.slots <- 
                'C:/Users/Jared/Documents/R/MarchMadness/TourneySlots.csv'
        
        # load files into data frames
        data.seeds <- read.csv(fp.seeds)
        data.slots <- read.csv(fp.slots)
        
        # filter datasets for selected year
        data.seeds.curr <- data.seeds %>%
                filter(Season == myYear)
        data.slots.curr <- data.slots %>%
                filter(Season == myYear)
              
        # pick random upset games - but exclude the first seed games
        gamesFilter <- c(1:32)[-c(1, 9, 17, 25)]
        upsetGames <- sample(gamesFilter, myUpsets, replace=F)
        
        # create a NULL variable to hold the tournament outcomes
        data.tournament.sim <- NULL
        
        # loop to simulate tournament rounds
        for(r in 1:7){
                if(r == 1){
                        data.seeds.round <- data.seeds.curr[grepl('a|b'
                                                  , data.seeds.curr$Seed), ]
                        names(data.seeds.round)[3] <- 'Team_Id'
                        data.seeds.round <- merge(data.seeds.round
                                                  , myData, sort = FALSE)
                } else if(r == 2){
                        data.seeds.round <- data.seeds.curr[!grepl('a|b'
                                                  , data.seeds.curr$Seed), ]
                        names(data.seeds.round)[3] <- 'Team_Id'
                        data.seeds.round <- merge(data.seeds.round
                                                  , myData, sort = FALSE)   
                        data.seeds.round <- rbind(data.seeds.round
                                                  , data.tournament.sim)  
                        data.tournament.sim <- data.seeds.round
                } else {
                        data.seeds.round <- data.tournament.sim
                }
                
                if(r == 1){
                       for(i in 1:nrow(data.seeds.round)){
                               if(i %% 2 != 0){
                                       t1 <- data.seeds.round[i, ]
                                       t2 <- data.seeds.round[i+1, ]
                                if(coinFlip == TRUE){
                                       coin <- sample(1:2, 1, FALSE)
                                         if(coin == 2){
                                                data.tournament.sim <- 
                                                  rbind(data.tournament.sim, t2)   
                                         } else {
                                                data.tournament.sim <- 
                                                  rbind(data.tournament.sim, t1)                                      
                                                }
                                          }else if(t1$rankings >= t2$rankings){
                                                data.tournament.sim <- 
                                                  rbind(data.tournament.sim, t1)   
                                                } else {
                                                data.tournament.sim <- 
                                                  rbind(data.tournament.sim, t2)                                      
                                                }
                               }
                       }
                       
               # remove a and b designations from the seed names
               data.tournament.sim$Seed <- gsub('a|b'
                                           , ''
                                           , data.tournament.sim$Seed)
                       
                } else {
                        data.slots.round <- data.slots.curr[grepl(paste('R', r-1, sep = '')
                                                                  , data.slots.curr$Slot), ]
                        
                        for(i in 1:nrow(data.slots.round)){
                                strong <- as.character(data.slots.round$Strongseed[i])
                                weak <- as.character(data.slots.round$Weakseed[i])
                                slot <- as.character(data.slots.round$Slot[i])
                                t1 <- data.seeds.round[data.seeds.round$Seed == strong, ]
                                t2 <- data.seeds.round[data.seeds.round$Seed == weak, ]
                                if(coinFlip == TRUE){
                                        coin <- sample(1:2, 1, FALSE)
                                         if(coin == 2){
                                                t2$Seed <- slot
                                                data.tournament.sim <- 
                                                rbind(data.tournament.sim, t2)    
                                         } else {
                                                t1$Seed <- slot
                                                data.tournament.sim <- 
                                                rbind(data.tournament.sim, t1)                                      
                                        }
                                } else if(r == 2 && i %in% upsetGames){
                                        if(t1$rankings >= t2$rankings){
                                                t2$Seed <- slot
                                                data.tournament.sim <- 
                                                rbind(data.tournament.sim, t2)    
                                         } else {
                                                t1$Seed <- slot
                                                data.tournament.sim <- 
                                                rbind(data.tournament.sim, t1)                                      
                                        }
                                        
                                } else {
                                        if(t1$rankings >= t2$rankings){
                                                t1$Seed <- slot
                                                data.tournament.sim <- 
                                                rbind(data.tournament.sim, t1)   
                                         } else {
                                                t2$Seed <- slot
                                                data.tournament.sim <- 
                                                rbind(data.tournament.sim, t2)                                      
                                        }
                                }
                        }
                }     
        }   
        
        write.csv(data.tournament.sim
                  ,paste('C:/Users/Jared/Documents/R/MarchMadness/Bracket_'
                         , myYear
                         ,'.csv'
                         , sep = ''))
                
        return(data.tournament.sim)
        
}

```


```{r, echo=FALSE, message=FALSE, warning=FALSE}


MarchMadnessBracket <- function(mySim, myYear){

        tourn_order.r2 <- c(1, 16, 8, 9, 5, 12, 4, 13, 6, 11, 3, 14, 7, 10, 2, 15)
        
        tourn.base <- mySim[1:64,3:5]
        tourn.base <- tourn.base[order(tourn.base$Seed),]
        
        tourn.r2.p1 <- tourn.base[1:16, ]
        tourn.r2.p1 <- tourn.r2.p1[tourn_order.r2, ]
        
        tourn.r2.p2 <- tourn.base[17:32, ]
        tourn.r2.p2 <- tourn.r2.p2[tourn_order.r2, ]
        
        tourn.r2.p3 <- tourn.base[33:48, ]
        tourn.r2.p3 <- tourn.r2.p3[tourn_order.r2, ]
        
        tourn.r2.p4 <- tourn.base[49:64, ]
        tourn.r2.p4 <- tourn.r2.p4[tourn_order.r2, ]
        
        tourn.r2 <- rbind(tourn.r2.p1, tourn.r2.p2, tourn.r2.p3, tourn.r2.p4)
        
        
        
        tourn_order.r3 <- c(1, 8, 5, 4, 6, 3, 7, 2)
        
        tourn.base <- mySim[65:96,3:5]
        
        tourn.r3.p1 <- tourn.base[1:8, ]
        tourn.r3.p1 <- tourn.r3.p1[tourn_order.r3, ]
        
        tourn.r3.p2 <- tourn.base[9:16, ]
        tourn.r3.p2 <- tourn.r3.p2[tourn_order.r3, ]
        
        tourn.r3.p3 <- tourn.base[17:24, ]
        tourn.r3.p3 <- tourn.r3.p3[tourn_order.r3, ]
        
        tourn.r3.p4 <- tourn.base[25:32, ]
        tourn.r3.p4 <- tourn.r3.p4[tourn_order.r3, ]
        
        tourn.r3 <- rbind(tourn.r3.p1, tourn.r3.p2, tourn.r3.p3, tourn.r3.p4)
        
        
        
        tourn_order.r4 <- c(1, 4, 3, 2)
        
        tourn.base <- mySim[97:112,3:5]
        
        tourn.r4.p1 <- tourn.base[1:4, ]
        tourn.r4.p1 <- tourn.r4.p1[tourn_order.r4, ]
        
        tourn.r4.p2 <- tourn.base[5:8, ]
        tourn.r4.p2 <- tourn.r4.p2[tourn_order.r4, ]
        
        tourn.r4.p3 <- tourn.base[9:12, ]
        tourn.r4.p3 <- tourn.r4.p3[tourn_order.r4, ]
        
        tourn.r4.p4 <- tourn.base[13:16, ]
        tourn.r4.p4 <- tourn.r4.p4[tourn_order.r4, ]
        
        tourn.r4 <- rbind(tourn.r4.p1, tourn.r4.p2, tourn.r4.p3, tourn.r4.p4)
        
        tourn.r5 <- mySim[113:120,3:5]
        tourn.r6 <- mySim[121:124,3:5]
        tourn.r7 <- mySim[125:126,3:5]
        tourn.ch <- mySim[127,3:5]
        
        par(mar=c(0,0,0,0) , bg="white" )
        plot(1,1,col="white",xlim=c(-5,130) , ylim=c(0,330) ,xaxt="n", yaxt="n" , bty="n" , xlab="" , ylab="")
        
        c <- 0.6
        myColor <- 'darkorange'
        checkYear <- as.numeric(substr(myYear, 1, 4))
        
        myRow <- 0
        mySlots <- tourn.r2
        slotNum <- nrow(tourn.r2)
        for(i in 1:32){
          
                x0 <- 0; y0 <- myRow; x1 <- 10; y1 <- myRow
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                label <- mySlots[ifelse(checkYear == 2017, slotNum - 32, slotNum), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x0, myRow + 3, labels = label, pos = 4, offset = 0, cex = c)
                
                x0 <- 120; y0 <- myRow; x1 <- 130; y1 <- myRow
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                label <- mySlots[ifelse(checkYear == 2017, slotNum, slotNum - 32), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x1, myRow + 3, labels = label, pos = 2, offset = 0, cex = c)
                
                myRow <- myRow + 10
                slotNum <- slotNum - 1
        }
        
        
        myRow <- 0
        mySlots <- tourn.r3
        slotNum <- nrow(tourn.r3)
        for(i in 1:16){
               
                x0 <- 10; y0 <- myRow + 5; x1 <- 20; y1 <- myRow + 5
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                label <- mySlots[ifelse(checkYear == 2017, slotNum - 16, slotNum), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x0 + 0.2, y0 + 3, labels = label, pos = 4, offset = 0, cex = c)
                
                x0 <- 10; y0 <- myRow; x1 <- 10; y1 <- myRow + 10
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                
                
                x0 <- 110; y0 <- myRow + 5; x1 <- 120; y1 <- myRow + 5
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                label <- mySlots[ifelse(checkYear == 2017, slotNum, slotNum - 16), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x1 - 0.2, y0 + 3, labels = label, pos = 2, offset = 0, cex = c)
                
                x0 <- 120; y0 <- myRow; x1 <- 120; y1 <- myRow + 10
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd")) 
                
                slotNum <- slotNum - 1
                myRow <- myRow + 20
        }
        
        myRow <- 10
        mySlots <- tourn.r4
        slotNum <- nrow(tourn.r4)
        for(i in 1:8){
                       
                x0 <- 20; y0 <- myRow + 5; x1 <- 30; y1 <- myRow + 5
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd")) 
                label <- mySlots[ifelse(checkYear == 2017, slotNum - 8, slotNum), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x0 + 0.2, y0 + 3, labels = label, offset = 0, pos = 4, cex = c)
                
                x0 <- 20; y0 <- myRow - 5; x1 <- 20; y1 <- myRow + 15
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                
                x0 <- 100; y0 <- myRow + 5; x1 <- 110; y1 <- myRow + 5
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                label <- mySlots[ifelse(checkYear == 2017, slotNum, slotNum - 8), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x1 - 0.2, y0 + 3, labels = label, pos = 2, offset = 0, cex = c)
                
                x0 <- 110; y0 <- myRow - 5; x1 <- 110; y1 <- myRow + 15
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                
                
                slotNum <- slotNum - 1
                myRow <- myRow + 40
        }
        
              
        myRow <- 30
        mySlots <- tourn.r5
        slotNum <- nrow(tourn.r5)
        for(i in 1:4){
               
                x0 <- 30; y0 <- myRow + 5; x1 <- 40; y1 <- myRow + 5
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                label <- mySlots[ifelse(checkYear == 2017, slotNum - 4, slotNum), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x0 + 0.2, y0 + 3, labels = label, offset = 0, pos = 4, cex = c)
                
                x0 <- 30; y0 <- myRow - 15; x1 <- 30; y1 <- myRow + 25
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                
                x0 <- 90; y0 <- myRow + 5; x1 <- 100; y1 <- myRow + 5
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                                label <- mySlots[ifelse(checkYear == 2017, slotNum, slotNum - 4), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x1 - 0.2, y0 + 3, labels = label, pos = 2, offset = 0, cex = c)
                
                x0 <- 100; y0 <- myRow - 15; x1 <- 100; y1 <- myRow + 25
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  

                
                slotNum <- slotNum - 1
                myRow <- myRow + 80
        }
        
        
        myRow <- 70
        mySlots <- tourn.r6
        slotNum <- nrow(tourn.r6)
        for(i in 1:2){
               
                x0 <- 40; y0 <- myRow + 5; x1 <- 50; y1 <- myRow + 5
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                label <- mySlots[ifelse(checkYear == 2017, slotNum - 2, slotNum), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x0 + 0.2, y0 + 3, labels = label, offset = 0, pos = 4, cex = c)
                
                x0 <- 40; y0 <- myRow - 35; x1 <- 40; y1 <- myRow + 45
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                
                x0 <- 80; y0 <- myRow + 5; x1 <- 90; y1 <- myRow + 5
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  
                label <- mySlots[ifelse(checkYear == 2017, slotNum, slotNum - 2), 2]
                #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
                text(x1 - 0.2, y0 + 3, labels = label, pos = 2, offset = 0, cex = c)
                
                x0 <- 90; y0 <- myRow - 35; x1 <- 90; y1 <- myRow + 45
                segments(x0, y0, x1, y1,
                        col = myColor, lty = par("lty"), lwd = par("lwd"))  

                
                slotNum <- slotNum - 1
                myRow <- myRow + 160
        }
        
        
        mySlots <- tourn.r7
        
        x0 <- 50; y0 <- 210; x1 <- 60; y1 <- 210
        segments(x0, y0, x1, y1,
                col = myColor, lty = par("lty"), lwd = par("lwd"))  
        label <- mySlots[ifelse(checkYear == 2017, 1, 2), 2]
        #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
        text(x0 + 0.2, y0 + 3, labels = label, offset = 0, pos = 4, cex = c)
        
        x0 <- 70; y0 <- 100; x1 <- 80; y1 <- 100
        segments(x0, y0, x1, y1,
                col = myColor, lty = par("lty"), lwd = par("lwd"))  
        label <- mySlots[ifelse(checkYear == 2017, 2, 1), 2]
        #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
        text(x1 - 0.2, y0 + 3, labels = label, offset = 0, pos = 2, cex = c)
         
        
        myRow <- 70
        
        x0 <- 50; y0 <- myRow + 5; x1 <- 50; y1 <- myRow + 165
        segments(x0, y0, x1, y1,
                col = myColor, lty = par("lty"), lwd = par("lwd"))  
        
        x0 <- 80; y0 <- myRow + 5; x1 <- 80; y1 <- myRow + 165
        segments(x0, y0, x1, y1,
                col = myColor, lty = par("lty"), lwd = par("lwd"))  
        
        
        mySlots <- tourn.ch
        rect(52, 135, 78, 195, col="transparent", border="darkorange", lwd = par("lwd"))
        x0 <- 60; y0 <- 165; x1 <- 70; y1 <- 165
        segments(x0, y0, x1, y1,
                col = myColor, lty = par("lty"), lwd = par("lwd"))  
        label <- mySlots[1, 2]
        #c <- ifelse(nchar(as.character(label)) >= 11, 0.45, 0.6)
        text(x0 + 5, y0 + 3, labels = label, offset = 0, pos = 3, cex = 0.6)
        

        img <- readPNG('C:/Users/Jared/Documents/R/MarchMadness/Logos_NCAA-MENS-BASKETBALL.png')
        rasterImage(img,50,250,80,350)
        #label = paste('NCAA\nMARCH MADNESS\n', myYear, sep = '')
        text(x0 + 5, 270, labels = myYear, offset = 0, pos = 1, cex = 1, col = 'black')
        #shadowtext(x0 + 5, y = 300, labels = label, col = 'deepskyblue2'
        #           , bg = 'black', theta = seq(pi/4, 2 * pi, length.out = 50), r = 0.1, cex = 1.5)
        

}

```

### Simulate 2015 and 2016 Brackets to Test Model

We can set parameters for the bracket calculations, including the year of the NCAA tournament we want to predict. Below I set the year to 2015. I set the score cap at 100, which essentially means no real cap on point spreads. Neutral location and away games are weighted 2 to 1 versus home games. I set equal weights for games at different times in the season and I set the random upsets to 0. Let's see what bracket the algorithm simulates with these parameters for 2015.


```{r, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2015
parScoreCap <- 100
parLocMod <- 2
parQ1Mod <- 1
parQ2Mod <- 1
parQ3Mod <- 1
parQ4Mod <- 1
parUpsets <- 0

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)
# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, parYear)


```

For 2015 I scored fairly well, with 1080 points out of a possible 1920 under **ESPNs Tournament Challenge** scoring system. For the Final Four, this simulation predicted three of the teams, but in the championship game the model forecast Kentucky to win over Duke, while in reality Duke won over Wisconsin. Let's see how the model performs for 2016, but this time I will cap the score at 17. 

```{r, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2016
parScoreCap <- 17
parLocMod <- 2
parQ1Mod <- 1
parQ2Mod <- 1
parQ3Mod <- 1
parQ4Mod <- 1
parUpsets <- 0

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)
# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, parYear)


```

My score was even better for 2016, with 1170 out of 1920. While I only had two of the Final Four selected correctly, I predicted the championship matchup of Villanova versus North Carolina. However, my model picked North Carolina to win, but in fact North Carolina was defeated by Villanova. Next we will move on to simulating the 2017 tournament brackets.

### Simulations for 2017

Since I've already demonstrated the R code for running and visualizing a simulation, I will hide the R code from here on out and just display the bracket predictions. For 2017 I am going to submit my 25 allowable brackets to the <a href="http://games.espn.com/tournament-challenge-bracket/2017/en/bracket" target="_blank">ESPN Tournament Challenge</a>. The first 12 of these brackets will be simulations using the ranking model with different parameters. The next 12 brackets will be coin flip simulations, where each matchup is given a 50/50 random chance. The last remaining bracket will be chosen by my wife Mary based on her own preferences, and will not be shown here. The first 12 are my model tests, while the next 12 are essentially controls. Presumably the model simulations should perform better than the coin flip simulations.

#### Ranking Model Simulation 1

 * Year = 2017
 * Score Cap = 100
 * Away/Neutral Game Weight = 1
 * Q1 Games Weight = 1
 * Q2 Games Weight = 1
 * Q3 Games Weight = 1
 * Q4 Games Weight = 1
 * Upsets = 0


```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 100
parLocMod <- 1
parQ1Mod <- 1
parQ2Mod <- 1
parQ3Mod <- 1
parQ4Mod <- 1
parUpsets <- 0

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)
# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 1', sep = ''))


```

#### Ranking Model Simulation 2

 * Year = 2017
 * Score Cap = 100
 * Away/Neutral Game Weight = 2
 * Q1 Games Weight = 1
 * Q2 Games Weight = 2
 * Q3 Games Weight = 3
 * Q4 Games Weight = 4
 * Upsets = 0

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 100
parLocMod <- 2
parQ1Mod <- 1
parQ2Mod <- 2
parQ3Mod <- 3
parQ4Mod <- 4
parUpsets <- 0

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)
# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 2', sep = ''))


```

#### Ranking Model Simulation 3

 * Year = 2017
 * Score Cap = 100
 * Away/Neutral Game Weight = 4
 * Q1 Games Weight = 1
 * Q2 Games Weight = 2
 * Q3 Games Weight = 4
 * Q4 Games Weight = 8
 * Upsets = 2

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 100
parLocMod <- 4
parQ1Mod <- 1
parQ2Mod <- 2
parQ3Mod <- 4
parQ4Mod <- 8
parUpsets <- 2

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)

set.seed(1111)

# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 3', sep = ''))


```

#### Ranking Model Simulation 4

 * Year = 2017
 * Score Cap = 100
 * Away/Neutral Game Weight = 4
 * Q1 Games Weight = 1
 * Q2 Games Weight = 4
 * Q3 Games Weight = 16
 * Q4 Games Weight = 64
 * Upsets = 6

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 100
parLocMod <- 4
parQ1Mod <- 1
parQ2Mod <- 4
parQ3Mod <- 16
parQ4Mod <- 64
parUpsets <- 6

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)

set.seed(1122)

# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 4', sep = ''))


```


#### Ranking Model Simulation 5

 * Year = 2017
 * Score Cap = 17
 * Away/Neutral Game Weight = 1
 * Q1 Games Weight = 1
 * Q2 Games Weight = 1
 * Q3 Games Weight = 1
 * Q4 Games Weight = 1
 * Upsets = 0

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 17
parLocMod <- 1
parQ1Mod <- 1
parQ2Mod <- 1
parQ3Mod <- 1
parQ4Mod <- 1
parUpsets <- 0

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)


# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 5', sep = ''))


```

#### Ranking Model Simulation 6

 * Year = 2017
 * Score Cap = 17
 * Away/Neutral Game Weight = 2
 * Q1 Games Weight = 1
 * Q2 Games Weight = 2
 * Q3 Games Weight = 3
 * Q4 Games Weight = 4
 * Upsets = 0

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 17
parLocMod <- 2
parQ1Mod <- 1
parQ2Mod <- 2
parQ3Mod <- 3
parQ4Mod <- 4
parUpsets <- 0

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)

# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 6', sep = ''))


```

#### Ranking Model Simulation 7

 * Year = 2017
 * Score Cap = 17
 * Away/Neutral Game Weight = 4
 * Q1 Games Weight = 1
 * Q2 Games Weight = 2
 * Q3 Games Weight = 4
 * Q4 Games Weight = 8
 * Upsets = 2

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 17
parLocMod <- 4
parQ1Mod <- 1
parQ2Mod <- 2
parQ3Mod <- 4
parQ4Mod <- 8
parUpsets <- 2

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)

set.seed(1133)

# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 7', sep = ''))


```

#### Ranking Model Simulation 8

 * Year = 2017
 * Score Cap = 17
 * Away/Neutral Game Weight = 4
 * Q1 Games Weight = 1
 * Q2 Games Weight = 4
 * Q3 Games Weight = 16
 * Q4 Games Weight = 64
 * Upsets = 6

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 17
parLocMod <- 4
parQ1Mod <- 1
parQ2Mod <- 4
parQ3Mod <- 16
parQ4Mod <- 64
parUpsets <- 6

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)

set.seed(1144)

# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 8', sep = ''))


```

#### Ranking Model Simulation 9

 * Year = 2017
 * Score Cap = 5
 * Away/Neutral Game Weight = 1
 * Q1 Games Weight = 1
 * Q2 Games Weight = 1
 * Q3 Games Weight = 1
 * Q4 Games Weight = 1
 * Upsets = 0

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 5
parLocMod <- 1
parQ1Mod <- 1
parQ2Mod <- 1
parQ3Mod <- 1
parQ4Mod <- 1
parUpsets <- 0

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)
# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 9', sep = ''))


```

#### Ranking Model Simulation 10

 * Year = 2017
 * Score Cap = 5
 * Away/Neutral Game Weight = 2
 * Q1 Games Weight = 1
 * Q2 Games Weight = 2
 * Q3 Games Weight = 4
 * Q4 Games Weight = 8
 * Upsets = 0

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 5
parLocMod <- 2
parQ1Mod <- 1
parQ2Mod <- 2
parQ3Mod <- 4
parQ4Mod <- 8
parUpsets <- 0

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)
# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 10', sep = ''))


```

#### Ranking Model Simulation 11

 * Year = 2017
 * Score Cap = 100
 * Away/Neutral Game Weight = 1
 * Q1 Games Weight = 1
 * Q2 Games Weight = 1
 * Q3 Games Weight = 1
 * Q4 Games Weight = 1
 * Upsets = 20

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 100
parLocMod <- 1
parQ1Mod <- 1
parQ2Mod <- 1
parQ3Mod <- 1
parQ4Mod <- 1
parUpsets <- 20

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)

set.seed(1155)

# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 11', sep = ''))


```

#### Ranking Model Simulation 12

 * Year = 2017
 * Score Cap = 100
 * Away/Neutral Game Weight = 10
 * Q1 Games Weight = 1
 * Q2 Games Weight = 2
 * Q3 Games Weight = 4
 * Q4 Games Weight = 8
 * Upsets = 6

```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 100
parLocMod <- 10
parQ1Mod <- 1
parQ2Mod <- 2
parQ3Mod <- 4
parQ4Mod <- 8
parUpsets <- 6

# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)

set.seed(1166)

# run the simulation
sim <- SimulateMarchMadness(ranks, parYear, parUpsets)

# create the bracket visual
MarchMadnessBracket(sim, paste(parYear, '\nModel Simulation 12', sep = ''))


```

#### Simulate 2017 Brackets 13 Through 24 Using Coin Flips

For the next set of simulations I will be overriding the normal ranking model and use a coin flip method for choosing winners. This feature gives me the ability to create random brackets to act as controls to compare against the brackets chosen by the predictive analytics method. This will tell us how well the algorithm for ranking teams performs against random chance, where hopefully it performs much better. Below are my next 12 brackets chosen using coin clip simulations.


```{r, echo = FALSE, message=FALSE, warning=FALSE}

# set parameters
parYear <- 2017
parScoreCap <- 100
parLocMod <- 2
parQ1Mod <- 1
parQ2Mod <- 1
parQ3Mod <- 1
parQ4Mod <- 1
parUpsets <- 8
parCoinFlip <- TRUE


# get the rankings
ranks <- GetNCAARankings(parYear, parScoreCap, parLocMod, 
                           parQ1Mod, parQ2Mod, parQ3Mod, parQ4Mod)

for(b in 1:12){
        
        
        set.seed(as.numeric(paste(1199, b, 00, sep='')))
        
        # run the simulation
        sim <- SimulateMarchMadness(ranks, parYear, parUpsets, parCoinFlip)
        
        # create the bracket visual
        MarchMadnessBracket(sim, paste(parYear, '\nCoin Flip Simulation ', b, sep = ''))
}

```


The brackets created by the ranking model show fairly stable outcomes under diverse parameter assumptions, with Gonzaga predicted to win it all in 9 out of 12 simulations. In the other 3 brackets, Kentucky wins twice and Wichita St wins once. There is more variation in the earlier rounds, with the Final Four matchups composed from combinations of 10 unique teams. The 64 first round games show the most diverse set of potential outcomes across the simulations, and likely this was influenced a lot by the addition of the random upsets parameter. It makes sense that the ranking model would be fairly stable, especially when choosing the tournament champion, because the parameters allow for only limited variation in how the rankings are chosen and it will tend to be the case that the highest ranking teams maintain those positions under different parameter scenarios.

This is in stark contrast to the 12 coin flip models, which show significant diversity in the brackets that are simulated. The only team that comes out on top more than once is North Dakota, with the other 10 tournament simulation champions being split between Oklahoma St, S Dakota St, Villanova, New Mexico St, Butler, Michigan, Florida, Wake Forest, Notre Dame, and Kansas. Anything can happen when the winners and losers are determined by random chance. It will be really interesting to see how the ranking model brackets stack up against the coin flip brackets.


### We Are the Champions

#### *Updated Sunday, April 9, 2017*

The 2017 NCAA Champions are the North Carolina Tar Heels, winning a hard fought victory over the Gonzaga Bulldogs. Where the typical sports commentator would discuss the game details, plays and players, I am interested in how our prediction model brackets scored in the ESPN Tournament Challenge.  Obviously, none of the twenty-four brackets I submitted to the ESPN Tournament Challenge correctly predicted that North Carolina would be the champions. However, nine out of twelve bracket simulations--specifically the ones built using the ranking model algorithm-had Gonzaga to win it. Given that Gonzaga had never before made it to the Final Four in NCAA history and that they ultimately came within seven points of being the champions, I would say that the ranking algorithm was successful at gleaning insight from the regular season games and applying that information to the prediction challenge. Recall that the ranking algorithm we used was the Massey Method, a technique that has been shown to be successful as this type of task in the past.

The real test is how well predictive models performed against other predicters, such as brackets chosen by random coin flip, brackets chosen by experienced watchers of the tournament, or brackets chosen by other mathematical predictive models. The two bar charts below rank the scores for our twelve ranking model simulations and the twelve coin flip simulations respectively. As you can see the ranking model simulations, with an average score of 752, significantly outperformed the coin flips simulations, with an average score of 298. Also, there is no overlap in scoring range between these two types of simulations, with the higher ranking coin flip simulation scoring 410 versus the lowest scoring ranking model at 520 points. The highest scoring ranking model simulation was 920 and this is more than double the highest scoring coin flip model. These scores differences tell us that the predictive models performed much better than random chance, much better than guessing. See the stack ranked bar charts below to see the points for each of our brackets. 



```{r, echo = FALSE, message=FALSE, warning=FALSE}

# create data frame with the scores for the modesl

model.scores <- data.frame(
        ModelName = c('Ranking Model Simulation 01'
                , 'Ranking Model Simulation 02'
                , 'Ranking Model Simulation 03'
                , 'Ranking Model Simulation 04'
                , 'Ranking Model Simulation 05'
                , 'Ranking Model Simulation 06'
                , 'Ranking Model Simulation 07'
                , 'Ranking Model Simulation 08'
                , 'Ranking Model Simulation 09'
                , 'Ranking Model Simulation 10'
                , 'Ranking Model Simulation 11'
                , 'Ranking Model Simulation 12'
                , 'Coin Flip Simulation 01'
                , 'Coin Flip Simulation 02'
                , 'Coin Flip Simulation 03'
                , 'Coin Flip Simulation 04'
                , 'Coin Flip Simulation 05'
                , 'Coin Flip Simulation 06'
                , 'Coin Flip Simulation 07'
                , 'Coin Flip Simulation 08'
                , 'Coin Flip Simulation 09'
                , 'Coin Flip Simulation 10'
                , 'Coin Flip Simulation 11'
                , 'Coin Flip Simulation 12')
        , Score = c(820
                , 860
                , 760
                , 620
                , 860
                , 780
                , 740
                , 520
                , 720
                , 690
                , 920
                , 740
                , 410
                , 160
                , 300
                , 230
                , 250
                , 410
                , 400
                , 300
                , 290
                , 220
                , 250
                , 360)
        , ModelDesc = c('score capped at 100; away/neutral games weighted by one; games by quarter weighted by one; zero random upsets'
, 'score capped at 100; away/neutral games weighted by two; games by quarter weighted by successive additions of one; zero random upsets'
, 'score capped at 100; away/neutral games weighted by four; games by quarter weighted by successive powers of two; two random upsets'
, 'score capped at 100; away/neutral games weighted by four; games by quarter weighted by successive powers of four; six random upsets'
, 'score capped at 17; away/neutral games weighted by one; games by quarter weighted by one; zero random upsets'
, 'score capped at 17; away/neutral games weighted by two; games by quarter weighted by successive additions of one; zero random upsets'
, 'score capped at 17; away/neutral games weighted by four; games by quarter weighted by successive powers of two; two random upsets'
, 'score capped at 17; away/neutral games weighted by four; games by quarter weighted by successive powers of four; six random upsets'
, 'score capped at 5; away/neutral games weighted by one; games by quarter weighted by one; zero random upsets'
, 'score capped at 5; away/neutral games weighted by two; games by quarter weighted by successive additions of one; zero random upsets'
, 'score capped at 100; away/neutral games weighted by one; games by quarter weighted by one; twenty random upsets'
, 'score capped at 100; away/neutral games weighted by ten; games by quarter weighted by successive powers of two; six random upsets'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'
, 'Random 50/50 chance for each game'))



cols <- c('darkblue', 'darkorange') 
pal <- colorRampPalette(cols)

chart.data <- arrange(model.scores[1:12, ], desc(Score))
chart.data$ModelName <- as.character(chart.data$ModelName)
chart.data$ModelDesc<- as.character(chart.data$ModelDesc)

myMean <- round(mean(chart.data$Score),0)
myMedian <- round(median(chart.data$Score), 0)
myLabel <- paste('Mean: ', myMean, '\nMedian: ', myMedian, sep = '')

g = ggplot(chart.data, aes(x = reorder(ModelName, desc(Score)), y=Score, 
                fill = reorder(ModelName, desc(Score)))) +
        theme_bw() +
        geom_bar(stat = 'identity') +
        #facet_grid(facets=. ~ Year) +
        scale_fill_manual(values = pal(12)) +
        #scale_y_continuous(labels = comma) + 
        ggtitle('March Madness - Ranking Model Simulations') +
        ylab('ESPN Bracket Score') + xlab('Simulation') +
        theme(axis.text.x = element_text(angle = 60, hjust = 1),
                #strip.text.x = element_text(size=10),      
                axis.title = element_text(size=10,face='bold'),
                panel.grid.major.x = element_blank(),
                panel.grid.major.y = element_blank(),
                #legend.direction = 'horizontal', 
                #legend.position = 'bottom', 
                #legend.text=element_text(size=10),
                legend.position='none') +
        #guides(fill=guide_legend(nrow=2,byrow=TRUE)) + 
        geom_label(aes(x = chart.data$ModelName, y = chart.data$Score - 60, label = '       '),
                size = 4, fill='white', alpha = 0.6, hjust = 'center', colour = 'white') +
        geom_text(aes(x = chart.data$ModelName, y = chart.data$Score - 60, fontface = 'bold', label = chart.data$Score)
                , size = 4) +
        geom_text(aes(x = 9, y = 850, fontface = 'bold', label = myLabel)
                , size = 3.5) 

g


cols <- c('darkblue', 'darkorange') 
pal <- colorRampPalette(cols)

chart.data <- arrange(model.scores[13:24, ], desc(Score))
chart.data$ModelName <- as.character(chart.data$ModelName)
chart.data$ModelDesc<- as.character(chart.data$ModelDesc)

myMean <- round(mean(chart.data$Score),0)
myMedian <- round(median(chart.data$Score), 0)
myLabel <- paste('Mean: ', myMean, '\nMedian: ', myMedian, sep = '')

g = ggplot(chart.data, aes(x = reorder(ModelName, desc(Score)), y=Score, 
                fill = reorder(ModelName, desc(Score)))) +
        theme_bw() +
        geom_bar(stat = 'identity') +
        #facet_grid(facets=. ~ Year) +
        scale_fill_manual(values = pal(12)) +
        #scale_y_continuous(labels = comma) + 
        ggtitle('March Madness - Coin Flip Simulations') +
        ylab('ESPN Bracket Score') + xlab('Simulation') +
        theme(axis.text.x = element_text(angle = 60, hjust = 1),
                #strip.text.x = element_text(size=10),      
                axis.title = element_text(size=10,face='bold'),
                panel.grid.major.x = element_blank(),
                panel.grid.major.y = element_blank(),
                #legend.direction = 'horizontal', 
                #legend.position = 'bottom', 
                #legend.text=element_text(size=10),
                legend.position='none') +
        #guides(fill=guide_legend(nrow=2,byrow=TRUE)) + 
        geom_label(aes(x = chart.data$ModelName, y = chart.data$Score - 20, label = '       '),
                size = 4, fill='white', alpha = 0.6, hjust = 'center', colour = 'white') +
        geom_text(aes(x = chart.data$ModelName, y = chart.data$Score - 20, fontface = 'bold', label = chart.data$Score)
                , size = 4) +
        geom_text(aes(x = 9, y = 375, fontface = 'bold', label = myLabel)
                , size = 3.5) 

g

```



To compare against other bracketologists we can use the information supplied by the ESPN Tournament Challenge smartphone app. The highest scoring bracket was Ranking Model Simulation 11, and with a score of 920 this was at the 80th percentile of all brackets submitted, which was about 19 million. Not bad. I'll take it, especially for a data science geek who knew nothing about the tournament beforehand. I know a lot now, so I won't be able to repeat this type of experiment again. If we consider the average ranking model bracket this puts the group at about the 62nd percentile, which is fairly modest overall. Incidentally the average score for the coin flip brackets is much lower at about the 3rd percentile, a fact that reinforces the idea that the tournament has elements that are predictable and not simply up to chance. 

A couple of other high profile bracket prediction models that used math as the basis for the choices are <a href="http://www.geekwire.com/2017/want-avoid-busted-bracket-bing-predicts-march-madness-winners-way-title-game/" target="_blank">Bing Predicts</a> and <a href="https://projects.fivethirtyeight.com/2017-march-madness-predictions/" target="_blank">FiveThirtyEight.com</a>. Bing Predicts uses "intelligent machine-learning technology to analyze social and search signals, plus more than a decade of college hoops statistical data" in order to formulate forecasts for March Madness. The model used by FiveThirtyEight applies six different ranking systems, including their own Elo rankings, to determine the probabilities for each team winning the tournament. If we score the pre-tournament brackets built from these other predictive analytics methods, both models suggested Villanova would be the champ and--under the ESPN Tournament challenge rules--scored 600 and 720 for Bing Predicts and FiveThirtyEight respectively. With our ranking model simulations we score higher than those comparable predictive models, with an average of 752 points. A decent performance.


Mathematically determined predictive models did not fair quite a well against experienced bracketologists who used their own judgment based on years of tournament watching. I submitted one of the ranking model brackets, specifically simulation model 5, to an ESPN group ran by my brother James. That bracket scored 860 points, but this placed it only fifth among nine entries. This hardly inspires bragging rights for that bracket. This indicates that domain knowledge is an important component of successful bracketology. This is not altogether surprising, as domain knowledge is an important factor in any data science endeavor. With an eyr toward improving the predictive accuracy for next year I will consider ways in which we might adapt some domain knowledge into our mathematical models.




